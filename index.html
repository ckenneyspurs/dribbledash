<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Spurs Dribble Dash â€” PoC</title>
  <style>
    body { 
      margin: 0; 
      background: #000; 
      color: #fff; 
      font-family: sans-serif; 
    }
    canvas { 
      background: linear-gradient(0deg, #e7c28f, #d8b17b); 
      display: block; 
      margin: 0 auto; 
    }
  </style>
</head>
<body>
  <canvas id="game" width="414" height="736"></canvas>
  
  <script>
    const W = 414, H = 736;
    const c = document.getElementById('game');
    const ctx = c.getContext('2d');
    
    let y = H / 2, vy = 0, score = 0;
    const ballR = 16;
    let obstacles = [], running = true;
    let t = 0;

    // Track restart button bounds after game over
    let restartBtn = null;

    function spawn() {
      const gap = 160;
      const top = Math.random() * (H - 300) + 50;
      obstacles.push({ x: W + 60, top: top, gap: gap });
    }

    function loop() {
      // Always draw one frame so we can show the overlay even when stopped
      ctx.clearRect(0, 0, W, H);

      if (running) {
        vy += 0.5;
        y += vy;

        if (y > H - 50) end();

        if (t % 100 === 0) spawn();

        obstacles.forEach(o => {
          o.x -= 2;
          ctx.fillStyle = '#111';
          ctx.fillRect(o.x, 0, 40, o.top);
          ctx.fillRect(o.x, o.top + o.gap, 40, H - (o.top + o.gap));

          if (o.x + 40 < 200 && !o.scored) {
            score++;
            o.scored = true;
          }

          if (
            circleRect(200, y, ballR, o.x, 0, 40, o.top) ||
            circleRect(200, y, ballR, o.x, o.top + o.gap, 40, H - (o.top + o.gap))
          ) end();
        });

        obstacles = obstacles.filter(o => o.x > -50);
      } else {
        // If not running, keep the last frame's obstacles/ball position visible (no updates)
      }

      // Draw player
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(200, y, ballR, 0, Math.PI * 2);
      ctx.fill();

      // Score
      ctx.fillStyle = '#fff';
      ctx.font = "16px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText('Score: ' + score, 10, 24);

      // If game over, draw overlay (so it persists)
      if (!running) {
        drawGameOverOverlay();
      }

      t++;
      requestAnimationFrame(loop);
    }

    function circleRect(cx, cy, cr, rx, ry, rw, rh) {
      const x = Math.max(rx, Math.min(cx, rx + rw));
      const y = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - x, dy = cy - y;
      return dx * dx + dy * dy <= cr * cr;
    }

    function end() {
     console.log("HERERERE");
     saveUser();
      running = false;
      // Prepare restart button bounds (centered)
      const btnW = 220, btnH = 48;
      const btnX = (W - btnW) / 2;
      const btnY = H / 2 + 80;
      restartBtn = { x: btnX, y: btnY, w: btnW, h: btnH };
      // The actual overlay is drawn each frame in drawGameOverOverlay()
    }

    function drawRoundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function drawGameOverOverlay() {
      // Dim background
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, W, H);

      // Title & score
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "bold 36px sans-serif";
      ctx.fillText("GAME OVER", W / 2, H / 2 - 40);

      ctx.font = "24px sans-serif";
      ctx.fillText("Score: " + score, W / 2, H / 2);

      
      // Restart button
      if (restartBtn) {
        // Button background
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 8;
        drawRoundedRect(restartBtn.x, restartBtn.y, restartBtn.w, restartBtn.h, 12);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
        ctx.restore();

        // Button label
        ctx.fillStyle = "#000";
        ctx.font = "bold 18px sans-serif";
        ctx.fillText("Restart", W / 2, restartBtn.y + restartBtn.h / 2 + 6);
      }

      // Hint
      ctx.fillStyle = "#fff";
      ctx.font = "16px sans-serif";
      ctx.fillText("Press SPACE or Tap the button", W / 2, restartBtn.y + restartBtn.h + 32);
    }

    function restartGame() {
      running = true;
      score = 0;
      y = H / 2;
      vy = 0;
      obstacles = [];
      t = 0;
      restartBtn = null;
      // loop() is already running via rAF; variables reset is enough
    }

    window.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        if (running) {
          vy = -8;
        } else {
          restartGame();
        }
      }
    });

    c.addEventListener('click', (evt) => {
      const rect = c.getBoundingClientRect();
      const mx = (evt.clientX - rect.left) * (c.width / rect.width);
      const my = (evt.clientY - rect.top) * (c.height / rect.height);

      if (running) {
        vy = -8;
      } else {
        // If game over, check restart button click
        if (restartBtn &&
            mx >= restartBtn.x && mx <= restartBtn.x + restartBtn.w &&
            my >= restartBtn.y && my <= restartBtn.y + restartBtn.h) {
          restartGame();
        }
      }
    });

    // ---- NBA API CALL ----
    async function saveUser() {
      try {
        const payload = {
          title: "dribble-dash",
          body: `latest score: ${score}`,
          userId: 1
        };

        const response = await fetch("https://jsonplaceholder.typicode.com/posts", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          throw new Error("Network response was not ok " + response.status + " " + response.statusText);
        }

        const data = await response.json();
        console.log("JSONPlaceholder POST response:", data);
      } catch (error) {
        console.error("Error posting to JSONPlaceholder:", error);
      }
    }

    // async function saveUser() 
    
    // { 
    //     try { 
    //         const response = await fetch("https://api.nba.com/v0/api/standings/league?leagueId=00&season=2024-25&seasonType=Regular%20Season"); 
    //         if (!response.ok) { throw new Error("Network response was not ok " + response.status + " " + response.statusText); } 
    //         const data = await response.json(); console.log("NBA Standings:", data); 
    //     } 
            
    //     catch (error) 
    //     { console.error("Error fetching NBA standings:", error); 
    // } 
// }

    // Start the loop
    loop();
  </script>
</body>
</html>
