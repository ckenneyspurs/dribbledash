<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Spurs Dribble Dash</title>
  <style>
    :root{
      --spurs-black:#000000;
      --spurs-silver:#C0C0C0;
      --spurs-gray:#2b2b2b;
      --court-wood1:#e7c28f;
      --court-wood2:#d8b17b;
      --ui:#111;
      --ui-ghost:#ffffffa8;
    }
    html,body{margin:0;height:100%;background:var(--spurs-black);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:#fff}
    .wrap{display:flex;flex-direction:column;align-items:center;gap:.5rem;padding:12px}
    canvas{background:linear-gradient(0deg,var(--court-wood1),var(--court-wood2));border:3px solid var(--spurs-silver);border-radius:16px;touch-action:none}
    .hud{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:center}
    .btn{appearance:none;border:2px solid var(--spurs-silver);color:#fff;background:var(--ui);padding:.5rem .8rem;border-radius:999px;font-weight:700;letter-spacing:.3px;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .title{font-weight:900;letter-spacing:.5px;text-transform:uppercase}
    .badge{padding:.25rem .6rem;border:1px solid var(--spurs-silver);border-radius:999px;background:#00000088}
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center}
    .card{background:#000000d0;border:2px solid var(--spurs-silver);border-radius:16px;padding:18px 16px;text-align:center;max-width:90vw}
    .brand{font-weight:900}
    .foot{opacity:.75;font-size:.85rem}
    a:link{color: grey}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud" style="gap:.6rem">
      <span class="title">Spurs Dribble Dash</span>
      <button id="btnStart" class="btn">Start</button>
      <button id="btnPause" class="btn">Pause</button>
      <button id="btnSound" class="btn">Sound: On</button>
      <span id="score" class="badge">Score: 0</span>
      <span id="best" class="badge">Best: 0</span>
    </div>
    <div style="position:relative">
      <canvas id="game" width="414" height="736" aria-label="Spurs Dribble Dash game canvas"></canvas>
      <div id="overlay" class="overlay">
        <div class="card">
          <div class="brand" style="font-size:1.2rem;margin-bottom:6px">San Antonio Spurs</div>
          <div style="font-size:1.6rem;font-weight:900;margin-bottom:6px">Dribble Dash</div>
          <p style="margin:.4rem 0 1rem">Tap / Click / Press Space to bounce the ball and weave past obstacles. Survive to score. üèÄ</p>
          <p style="margin:.2rem 0 .8rem">Tip: short, rhythmic taps mimic a dribble; longer holds give a stronger hop.</p>
          <p style="margin:.2rem 0 .8rem">By hitting 'Play' you agree to the official sweepstakes rules</p>
          <a href="https://cdn.nba.com/teams/uploads/sites/1610612759/2025/10/Autographed-Ball_Sweepstakes-Rule-1.pdf">Learn More</a>
          <br>
          <br>
          <button id="btnOverlayStart" class="btn">Play</button>
        </div>
      </div>
    </div>
    <div class="foot">Controls: Tap / Click / Space to bounce ‚Ä¢ P to pause ‚Ä¢ R to restart</div>
  </div>

  <script>
  // Spurs Dribble Dash ‚Äî Playable PoC
  // Single-file HTML5 Canvas game inspired by "Flappy" flow, themed to a basketball dribble.
  // ¬© Spurs Sports & Entertainment (PoC). No external assets required.

  const W = 414, H = 736; // iPhone 11-ish aspect, good baseline for mobile
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnSound = document.getElementById('btnSound');
  const btnOverlayStart = document.getElementById('btnOverlayStart');

  // Audio (tiny, no files)
  let audioEnabled = true;
  let ACtx = null;
  function beep(freq=600, dur=0.06, type='square', vol=0.05){
    try{
      if(!audioEnabled) return;
      if(!ACtx) ACtx = new (window.AudioContext || window.webkitAudioContext)();
      const t = ACtx.currentTime;
      const o = ACtx.createOscillator();
      const g = ACtx.createGain();
      o.type = type; o.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(vol, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      o.connect(g).connect(ACtx.destination);
      o.start(t); o.stop(t + dur);
    }catch(e){/* ignore */}
  }

  // Game state
  const state = {
    running: false,
    paused: false,
    t: 0,
    score: 0,
    best: Number(localStorage.getItem('spurs_dd_best')||0),
    speed: 180, // px/sec horizontal world speed
    gravity: 1300, // px/sec^2
    bounce: 420,  // initial vertical impulse when dribbling
    maxVelY: 900,
    obstacles: [],
    floorY: H - 80,
    laneTop: 110,
    nextSpawn: 0,
    spawnInterval: [1.0, 1.8], // seconds, tight early pacing
    rngSeed: Date.now() % 2147483647
  };

  // Simple RNG for determinism per run
  function rnd(){ state.rngSeed = (state.rngSeed * 48271) % 2147483647; return state.rngSeed / 2147483647; }
  function randRange(a,b){ return a + rnd()*(b-a); }

  // Player (ball)
  const ball = {
    x: W*0.28,
    y: H*0.5,
    r: 16,
    vy: 0,
    spin: 0
  };

  // Input
  let pressed = false;
  const pressOn = ()=>{ pressed = true; if(!state.running) startGame(); dribble(); };
  const pressOff = ()=>{ pressed = false; };

  canvas.addEventListener('pointerdown', pressOn);
  window.addEventListener('pointerup', pressOff);
  window.addEventListener('keydown', e=>{
    if(e.code==='Space'){ e.preventDefault(); pressOn(); }
    if(e.key==='p' || e.key==='P') togglePause();
    if(e.key==='r' || e.key==='R') resetGame();
  });
  window.addEventListener('keyup', e=>{ if(e.code==='Space') pressOff(); });

  btnStart.onclick = ()=>{ if(!state.running) startGame(); };
  btnPause.onclick = ()=> togglePause();
  btnSound.onclick = ()=>{ audioEnabled=!audioEnabled; btnSound.textContent = `Sound: ${audioEnabled? 'On':'Off'}`; };
  btnOverlayStart.onclick = ()=>{ startGame(); };

  function showOverlay(show){ overlay.style.display = show? 'flex':'none'; }

  function startGame(){
    state.running = true; state.paused = false; state.t = 0; state.score = 0;
    state.speed = 200; state.gravity = 1400; state.bounce = 460; state.maxVelY = 1000;
    state.obstacles.length = 0; state.nextSpawn = 0; state.rngSeed = Date.now()%2147483647;
    ball.x = W*0.28; ball.y = H*0.5; ball.vy = 0; ball.spin = 0;
    lastTs = performance.now();
    showOverlay(false);
    loop(lastTs);
  }

  function resetGame(){
    state.running = false; showOverlay(true);
  }

  function togglePause(){
    if(!state.running) return;
    state.paused = !state.paused;
    if(!state.paused){ lastTs = performance.now(); loop(lastTs); }
  }

  function dribble(){
    // Apply a vertical impulse; slightly stronger if user is holding
    const impulse = pressed ? state.bounce * 1.08 : state.bounce;
    ball.vy = -impulse; // upward
    beep(440, 0.04, 'sine', 0.04);
  }

  // Obstacles are pairs: top bar (from laneTop down) and bottom bar (from floor up), with a gap
  function spawnObstacle(){
    const minGap = 150, maxGap = 220; // mobile friendly
    const gap = randRange(minGap, maxGap);
    const maxTop = state.floorY - gap - state.laneTop - 40;
    const topH = randRange(30, Math.max(30, maxTop));
    const width = randRange(44, 64);
    const x = W + 40;
    state.obstacles.push({ x, width, topH, gap, passed:false });
  }

  function rectsCollide(rx,ry,rw,rh, cx,cy,cr){
    // Circle-rect collision
    const closestX = Math.max(rx, Math.min(cx, rx+rw));
    const closestY = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - closestX, dy = cy - closestY;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  let lastTs = performance.now();
  function loop(ts){
    if(!state.running) return;
    const dt = Math.min(0.033, (ts - lastTs)/1000); // clamp
    lastTs = ts;

    if(!state.paused){
      update(dt);
      draw();
    }
    requestAnimationFrame(loop);
  }

  function update(dt){
    state.t += dt;

    // Difficulty ramps
    state.speed += 2 * dt; // slow ramp

    // Spawn logic
    state.nextSpawn -= dt;
    if(state.nextSpawn <= 0){
      spawnObstacle();
      state.nextSpawn = randRange(state.spawnInterval[0], state.spawnInterval[1]);
      // slowly tighten spawn interval
      state.spawnInterval[0] = Math.max(0.8, state.spawnInterval[0] - 0.005);
      state.spawnInterval[1] = Math.max(1.4, state.spawnInterval[1] - 0.004);
    }

    // Physics ‚Äî ball
    ball.vy += state.gravity * dt;
    ball.vy = Math.min(ball.vy, state.maxVelY);
    ball.y += ball.vy * dt;
    ball.spin += (ball.vy * dt) * 0.02;

    // Floor / ceiling
    if(ball.y + ball.r >= state.floorY){
      ball.y = state.floorY - ball.r; ball.vy = 0;
      // Auto-bounce tiny if holding, to mimic dribble cadence
      if(pressed){ dribble(); }
      else gameOver();
    }
    if(ball.y - ball.r < state.laneTop){ ball.y = state.laneTop + ball.r; ball.vy = 60; }

    // Obstacles movement & scoring
    for(const ob of state.obstacles){
      ob.x -= state.speed * dt;
      // Score when center passes
      if(!ob.passed && ob.x + ob.width < ball.x){
        ob.passed = true; state.score++;
        scoreEl.textContent = `Score: ${state.score}`;
        beep(760, 0.05, 'triangle', 0.035);
      }
    }
    // Remove off-screen
    while(state.obstacles.length && state.obstacles[0].x + state.obstacles[0].width < -60){ state.obstacles.shift(); }

    // Collisions with top/bottom bars
    for(const ob of state.obstacles){
      const gapY = state.laneTop + ob.topH;
      // Top rect
      if(rectsCollide(ob.x, state.laneTop, ob.width, ob.topH, ball.x, ball.y, ball.r)) return gameOver();
      // Bottom rect
      const bottomH = state.floorY - (gapY + ob.gap);
      if(rectsCollide(ob.x, gapY + ob.gap, ob.width, bottomH, ball.x, ball.y, ball.r)) return gameOver();
    }
  }

  function gameOver(){
    beep(180, 0.20, 'sawtooth', 0.05);
    state.running = false;
    if(state.score > state.best){ state.best = state.score; localStorage.setItem('spurs_dd_best', String(state.best)); }
    bestEl.textContent = `Best: ${state.best}`;
    setTimeout(()=>{ showOverlay(true); }, 150);
  }

  function drawCourt(){
    // Wood planks
    const plankH = 24; let y=0; let i=0;
    while(y < H){
      ctx.fillStyle = (i%2===0) ? '#e8c99b' : '#e1bd89';
      ctx.fillRect(0,y,W,plankH); y += plankH; i++;
    }
    // Sidelines, baselines
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--spurs-silver');
    ctx.lineWidth = 4;
    ctx.strokeRect(10, state.laneTop-6, W-20, state.floorY - state.laneTop + 12);

    // Center court circle w/ simple Spurs motif (neutral, no logo asset)
    ctx.beginPath(); ctx.arc(W*0.5, H*0.35, 56, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(W*0.5, H*0.35, 34, 0, Math.PI*2); ctx.stroke();
    ctx.font = '900 14px system-ui'; ctx.textAlign='center'; ctx.fillStyle = '#111';
    ctx.fillText('SPURS', W*0.5, H*0.35 + 5);

    // Paint a darker lane towards the bottom to suggest near-basket area
    ctx.fillStyle = '#0000000f';
    ctx.fillRect(W*0.25, H*0.68, W*0.5, state.floorY - H*0.68);
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    drawCourt();

    // Obstacles (cones/defenders stylized bars)
    for(const ob of state.obstacles){
      const gapY = state.laneTop + ob.topH;
      ctx.fillStyle = '#1d1d1d';
      // top bar
      roundRect(ctx, ob.x, state.laneTop, ob.width, ob.topH, 10); ctx.fill();
      // bottom bar
      const bottomH = state.floorY - (gapY + ob.gap);
      roundRect(ctx, ob.x, gapY + ob.gap, ob.width, bottomH, 10); ctx.fill();
      // Spur of silver accent
      ctx.fillStyle = '#C0C0C0';
      ctx.fillRect(ob.x+4, gapY-6, ob.width-8, 3);
    }

    // Shadow
    const shadowScale = 1 - Math.min(1, (ball.y - state.laneTop) / (state.floorY - state.laneTop));
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    const sw = ball.r*1.4*shadowScale, sh = 6*shadowScale;
    ctx.beginPath(); ctx.ellipse(ball.x, state.floorY+2, sw, sh, 0, 0, Math.PI*2); ctx.fill();

    // Ball (black/silver paneling)
    ctx.save();
    ctx.translate(ball.x, ball.y);
    ctx.rotate(ball.spin);
    const grad = ctx.createRadialGradient(-6,-6,4,0,0,ball.r+4);
    grad.addColorStop(0,'#ffffffaa'); grad.addColorStop(1,'#111');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(0,0,ball.r,0,Math.PI*2); ctx.fill();
    ctx.lineWidth = 2; ctx.strokeStyle = '#C0C0C0';
    // panel lines
    ctx.beginPath(); ctx.arc(0,0, ball.r*0.65, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-ball.r,0); ctx.lineTo(ball.r,0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,-ball.r); ctx.lineTo(0,ball.r); ctx.stroke();
    ctx.restore();

    // UI
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0,0,W,28);
    ctx.fillStyle = '#fff';
    ctx.font = '700 14px system-ui';
    ctx.fillText(`Score ${state.score}`, 32, 20);
    ctx.textAlign = 'right';
    ctx.fillText(`Best ${state.best}`, W-12, 20);
    ctx.textAlign = 'left';

    if(state.paused){ drawPaused(); }
  }

  function drawPaused(){
    ctx.fillStyle = '#000000aa'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.font = '900 26px system-ui';
    ctx.textAlign='center'; ctx.fillText('Paused', W/2, H/2 - 8);
    ctx.font = '500 14px system-ui'; ctx.fillText('Tap P to resume', W/2, H/2 + 18);
  }

  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // Fit canvas to device pixel ratio for crispness
  function fitCanvas(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const styleW = Math.min(480, window.innerWidth - 24);
    const styleH = Math.min(820, window.innerHeight - 180);
    const aspect = H/W; let w = styleW; let h = w*aspect;
    if(h > styleH){ h = styleH; w = h/aspect; }
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.round(w*dpr);
    canvas.height = Math.round(h*dpr);
    // scale drawing to our logical W,H
    ctx.setTransform(canvas.width/W, 0, 0, canvas.height/H, 0, 0);
  }

  window.addEventListener('resize', fitCanvas); fitCanvas();
  bestEl.textContent = `Best: ${state.best}`;
  scoreEl.textContent = `Score: ${state.score}`;
  showOverlay(true);
  draw();
  </script>
</body>
</html>